# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Consumo_servicio_IGACDockWidget
                                 A QGIS plugin
 Plugin para cosumir servicio estaciones CORS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-04-28
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ricardo cepeda
        email                : idu054441@usal.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import requests
import json
import csv 
from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsVectorLayer, QgsProject,QgsVectorFileWriter
from qgis.PyQt.QtCore import pyqtSignal

# Cargar la clase de interfaz de usuario generada desde el archivo .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'Validador_CORS_dockwidget_base.ui'))

class Consumo_servicio_IGACDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        super(Consumo_servicio_IGACDockWidget, self).__init__(parent)
        self.setupUi(self)

        # Inicializar la ruta donde quedará almacenada la geometría (SHP o GeoJson)
        self.file_path = None

        # Inicializar las QProgressBar
        self.barra_activas = self.findChild(QtWidgets.QProgressBar, 'barra_activas')
        self.barra_inactivas = self.findChild(QtWidgets.QProgressBar, 'barra_inactivas')

        # Conectar señales y slots
        self.btn_consumir.clicked.connect(self.on_button_consumir_clicked)
        self.btn_graficar.clicked.connect(self.on_button_graficar_clicked)
        self.btn_exportar.clicked.connect(self.on_button_exportar_clicked)
        self.btn_csv.clicked.connect(self.on_button_csv_clicked)
        self.filtro.currentIndexChanged.connect(self.filtrar_tabla)
  
    def on_button_consumir_clicked(self):
        # definición URL del servicio REST Consumido
        url = 'https://mapas.igac.gov.co/server/rest/services/centrocontrol/EstacionesGNSS/MapServer/0/query'

        # Mostrar la URL en el QLineEdit 'texto'
        self.texto.setText(url)
        # Parámetros para la consulta (obtener todas las estaciones como puntos)
        params = {
            'f': 'json',  # Formato de respuesta en JSON
            'where': '1=1',  # Consulta para obtener todas las entidades
            'outFields': '*',  # Todos los campos
            'geometryType': 'esriGeometryPoint',  # Tipo de geometría de puntos
            'spatialRel': 'esriSpatialRelIntersects',  # Relación espacial
            'returnGeometry': True  # Incluir geometría en la respuesta
        }

        try:
            # Abrir un cuadro de diálogo para seleccionar la ruta de guardado del archivo en formato geojson
            file_dialog = QtWidgets.QFileDialog()
            file_dialog.setFileMode(QtWidgets.QFileDialog.AnyFile)
            file_dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
            file_dialog.setNameFilter("GeoJSON (*.geojson)")

             # Punto de control, Si el usuario selecciona una ruta y confirma el diálogo
            if file_dialog.exec_():
                  # Obtener la ruta de guardado seleccionada
                save_file_path = file_dialog.selectedFiles()[0]
                
                # Realizar la solicitud GET al servicio con los parámetros
                response = requests.get(url, params=params)

                # Verificar el código de estado de la respuesta
                if response.status_code == 200:
                    # Convertir la respuesta JSON a un diccionario Python
                    data = response.json()

                    # Guardar los datos de geometría como un archivo GeoJSON
                    with open(save_file_path, 'w') as geojson_file:
                        json.dump(data, geojson_file)

                    # Actualizar la ruta guardado de la geometría con la del GeoJson
                    self.file_path = save_file_path

                    QtWidgets.QMessageBox.information(self, 'Estado de conexión', 'Datos de estaciones tipo punto descargados y guardados.')

                    # Mostrar los datos en el table widget
                    self.mostrar_datos_en_tabla()
                     # Actualizar otros elementos de la interfaz de usuario según sea necesario
                    self.actualizar_contadores()

            # Se muestra mensaje de advertencia en caso de que la solicitud no sea exitosa
            # El mensaje que se muestra al usuario incluye el código de estado de la respuesta HTTP
                else:
                    
                    QtWidgets.QMessageBox.warning(self, 'Error de conexión al servicio', f'Error al conectar al servicio. Código de estado: {response.status_code}')

    # Si ocurre una excepción relacionada con la solicitud HTTP se muestra mensaje de error al usuario
    # Se incluye información sobre el problema
        except requests.exceptions.RequestException as e:
            QtWidgets.QMessageBox.critical(self, 'Error de conexión', f'Error de conexión: {str(e)}')

    def mostrar_datos_en_tabla(self):
        # Verificar si hay un archivo  cargado
        if self.file_path:
            # Cargar el archivo en QGIS
            layer = QgsVectorLayer(self.file_path, 'Estaciones Punto', 'ogr')
            if layer.isValid():
                # Limpiar la tabla antes de agregar nuevos datos
                self.tabla.setRowCount(0)
                
                # Obtener los campos de interés
                fields = ['identificador', 'nombre_municipio', 'estado']

                # Iterar sobre las entidades de la capa y agregar filas a la tabla
                for feature in layer.getFeatures():
                    # Obtener los valores de los atributos de interés para cada entidad
                    values = [feature[attribute] for attribute in fields]
                    # Agregar una fila a la tabla con los valores de los atributos
                    self.agregar_fila_en_tabla(values)
                # Mostrar un mensaje informativo indicando que la capa se ha agregado con éxito a QGIS
                QtWidgets.QMessageBox.information(self, 'Capa agregada', 'Capa de estaciones tipo punto agregada al proyecto de QGIS.')
            else:
                # Mostrar un mensaje de advertencia si no se pudo cargar la capa 
                QtWidgets.QMessageBox.warning(self, 'Error al cargar capa', 'No se pudo cargar la capa.')
        else:
            # Mostrar un mensaje de advertencia si no se ha descargado ninguna capa todavía
            QtWidgets.QMessageBox.warning(self, 'Sin capa de información', 'Primero descarga los datos usando el botón "Consumir".')

    def agregar_fila_en_tabla(self, values):
        # Insertar una nueva fila en la tabla
        row_position = self.tabla.rowCount()
        self.tabla.insertRow(row_position)

        # Agregar los valores a la fila
        for column, value in enumerate(values):
            item = QtWidgets.QTableWidgetItem(str(value))
            self.tabla.setItem(row_position, column, item)

    def actualizar_contadores(self):
        if self.file_path:
            # Cargar la capa en QGIS
            layer = QgsVectorLayer(self.file_path, 'Estaciones Punto', 'ogr')
            if layer.isValid():
                # Contar las estaciones con estado 'Activa' e 'Inactiva'
                count_activas = sum(1 for feature in layer.getFeatures() if feature['estado'] == 'Activa')
                count_inactivas = sum(1 for feature in layer.getFeatures() if feature['estado'] == 'Inactiva')

                # Mostrar los contadores en los QLCDNumber correspondientes
                self.contador_activas.display(count_activas)
                self.contador_inactivas.display(count_inactivas)

                # Obtener el total combinado de estaciones activas e inactivas
                total_estaciones = count_activas + count_inactivas

                # Calcular el porcentaje de estaciones activas e inactivas individualmente acorde a los valores 
                #previamente calculados
                porcentaje_activas = (count_activas / total_estaciones) * 100 if total_estaciones > 0 else 0
                porcentaje_inactivas = (count_inactivas / total_estaciones) * 100 if total_estaciones > 0 else 0

                # Actualizar las QProgressBar - se suma una unidad para completar el 100%
                self.barra_activas.setValue(int(porcentaje_activas) +int(1))
                self.barra_inactivas.setValue(int(porcentaje_inactivas))

            else:
                # Si la ruta del shapefile no está definida, mostrar un mensaje de advertencia indicando que primero se deben descargar los datos
                QtWidgets.QMessageBox.warning(self, 'Error al cargar capa', 'No se pudo cargar la capa.')
        else:
            # Si la capa no es válida (si la capa no carga correctamente), mostrar un mensaje de advertencia
            QtWidgets.QMessageBox.warning(self, 'Sin capa de información', 'Primero descarga los datos usando el botón "Consumir".')


    def on_button_graficar_clicked(self):
        # Verificar si hay un archivo  cargado
        if self.file_path:
            # Cargar el archvo en QGIS
            layer = QgsVectorLayer(self.file_path, 'Estaciones Punto', 'ogr')
            # Verificar si la capa es válida
            if layer.isValid():
                # Agregar la capa al proyecto de QGIS
                QgsProject.instance().addMapLayer(layer)
                # Se muestra un mensaje informativo indicando que la capa se ha agregado con éxito a QGIS
                QtWidgets.QMessageBox.information(self, 'Capa agregada', 'Capa de estaciones tipo punto agregada al proyecto de QGIS.')
            else:
                 # Se muestra  un mensaje de advertencia si no se pudo cargar la capa s
                QtWidgets.QMessageBox.warning(self, 'Error al cargar capa', 'No se pudo cargar la capa.')
        else:
            # Se muestra  un mensaje de advertencia si no se ha descargado ninguna capa todavía
            QtWidgets.QMessageBox.warning(self, 'Sin capa de información', 'Primero descarga los datos usando el botón "Consumir".')
    
    
    
    def on_button_exportar_clicked(self):
        if self.file_path:
            # Cargar la capa desde el archivo GeoJSON guardado
            layer = QgsVectorLayer(self.file_path, 'Estaciones Punto', 'ogr')
            if layer.isValid():
                # Abrir un cuadro de diálogo para seleccionar la ruta de guardado del Shapefile
                file_dialog = QtWidgets.QFileDialog()
                file_dialog.setFileMode(QtWidgets.QFileDialog.AnyFile)
                file_dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
                file_dialog.setNameFilter("Shapefile (*.shp)")
                if file_dialog.exec_():
                     # Obtener la ruta seleccionada para guardar el Shapefile
                    file_path = file_dialog.selectedFiles()[0]

                    # Exportar la capa a Shapefile
                    QgsVectorFileWriter.writeAsVectorFormat(layer, file_path, "UTF-8", layer.crs(), "ESRI Shapefile")

                    QtWidgets.QMessageBox.information(self, 'Capa exportada', 'Capa exportada a Shapefile correctamente.')
                else:
                    QtWidgets.QMessageBox.warning(self, 'Cancelado', 'Operación de exportación cancelada.')
            else:
                QtWidgets.QMessageBox.warning(self, 'Error al cargar capa', 'No se pudo cargar capa.')
        else:
            QtWidgets.QMessageBox.warning(self, 'Sin información fuente', 'Primero descarga los datos usando el botón "Consumir".')
    
    def on_button_csv_clicked(self):
        # Obtener los datos de la tabla y escribir en un archivo CSV
        file_dialog = QtWidgets.QFileDialog()
        file_dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        file_dialog.setNameFilter("CSV (*.csv)")

        if file_dialog.exec_():
            csv_file_path = file_dialog.selectedFiles()[0]

            with open(csv_file_path, 'w', newline='') as csvfile:
                csv_writer = csv.writer(csvfile)
                
                # Escribir encabezados de columna
                headers = [self.tabla.horizontalHeaderItem(i).text() for i in range(self.tabla.columnCount())]
                csv_writer.writerow(headers)

                # Escribir filas de datos
                for row in range(self.tabla.rowCount()):
                    row_data = [self.tabla.item(row, col).text() for col in range(self.tabla.columnCount())]
                    csv_writer.writerow(row_data)

            QtWidgets.QMessageBox.information(self, 'Exportación CSV', 'Datos exportados correctamente a CSV.')
    

    def filtrar_tabla(self, index):
        estado_seleccionado = self.filtro.currentText()
        num_filas = self.tabla.rowCount()
        column_index = 2  # Índice de la columna de estado sobre la cual se aplica el filtro

        #Iteración sobre la tabla 
        for row in range(num_filas):
            estado_fila = self.tabla.item(row, column_index).text()
            #Aplicación de filtros acorde al estado
            if estado_seleccionado == "Todos":
                # Mostrar todas las filas
                self.tabla.setRowHidden(row, False)
            elif estado_seleccionado == "Activas":
                # Mostrar solo las filas con estado "Activa"
                if estado_fila.lower() == "activa":
                    self.tabla.setRowHidden(row, False)
                else:
                    self.tabla.setRowHidden(row, True)
            elif estado_seleccionado == "Inactivas":
                # Mostrar solo las filas con estado "Inactiva"
                if estado_fila.lower() == "inactiva":
                    self.tabla.setRowHidden(row, False)
                else:
                    self.tabla.setRowHidden(row, True)
            else:
                # Opción no válida; mostrar todas las filas por defecto
                self.tabla.setRowHidden(row, False)
                
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()